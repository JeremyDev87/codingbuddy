/**
 * Config Renderer
 *
 * Renders config objects (from wizard) to JavaScript or JSON format
 */

interface ConfigObject {
  language?: string;
  projectName?: string;
  description?: string;
  techStack?: {
    languages?: string[];
    frontend?: string[];
    backend?: string[];
    database?: string[];
    infrastructure?: string[];
    tools?: string[];
  };
  architecture?: {
    pattern?: string;
    componentStyle?: string;
    structure?: string[];
  };
  conventions?: {
    naming?: {
      files?: string;
      components?: string;
      functions?: string;
      variables?: string;
    };
    quotes?: string;
    semicolons?: boolean;
  };
  testStrategy?: {
    approach?: string;
    coverage?: number;
    mockingStrategy?: string;
    frameworks?: string[];
  };
  ai?: {
    defaultModel?: string;
    primaryAgent?: string;
  };
}

/**
 * Render a config object as JavaScript module with comments
 */
export function renderConfigObjectAsJs(config: ConfigObject): string {
  const lines: string[] = [];

  // Header
  lines.push('/**');
  lines.push(' * Codingbuddy Configuration');
  lines.push(' *');
  lines.push(' * Generated by `codingbuddy init`');
  lines.push(' * @see https://github.com/anthropics/codingbuddy');
  lines.push(' */');
  lines.push('');

  lines.push('module.exports = {');

  // Language
  if (config.language) {
    lines.push(`  language: '${escapeJsString(config.language)}',`);
    lines.push('');
  }

  // Project Info
  if (config.projectName) {
    lines.push(`  projectName: '${escapeJsString(config.projectName)}',`);
  }
  if (config.description) {
    lines.push(`  description: '${escapeJsString(config.description)}',`);
  }
  if (config.projectName || config.description) {
    lines.push('');
  }

  // Tech Stack
  if (config.techStack && hasNonEmptyArrays(config.techStack)) {
    lines.push('  techStack: {');
    lines.push(...renderTechStack(config.techStack));
    lines.push('  },');
    lines.push('');
  }

  // Architecture
  if (config.architecture && hasProperties(config.architecture)) {
    lines.push('  architecture: {');
    lines.push(...renderArchitecture(config.architecture));
    lines.push('  },');
    lines.push('');
  }

  // Conventions
  if (config.conventions && hasProperties(config.conventions)) {
    lines.push('  conventions: {');
    lines.push(...renderConventions(config.conventions));
    lines.push('  },');
    lines.push('');
  }

  // Test Strategy
  if (config.testStrategy && hasProperties(config.testStrategy)) {
    lines.push('  testStrategy: {');
    lines.push(...renderTestStrategy(config.testStrategy));
    lines.push('  },');
    lines.push('');
  }

  // AI Configuration
  if (config.ai && hasProperties(config.ai)) {
    lines.push('  ai: {');
    if (config.ai.defaultModel) {
      lines.push(
        `    defaultModel: '${escapeJsString(config.ai.defaultModel)}',`,
      );
    }
    if (config.ai.primaryAgent) {
      lines.push(
        `    primaryAgent: '${escapeJsString(config.ai.primaryAgent)}',`,
      );
    }
    lines.push('  },');
  }

  lines.push('};');

  return lines.join('\n');
}

/**
 * Render a config object as JSON
 */
export function renderConfigObjectAsJson(config: ConfigObject): string {
  const cleanedConfig = cleanConfig(config);
  return JSON.stringify(cleanedConfig, null, 2);
}

/**
 * Clean config by removing empty arrays and undefined values
 */
function cleanConfig(config: ConfigObject): ConfigObject {
  const result: ConfigObject = {};

  if (config.language) result.language = config.language;
  if (config.projectName) result.projectName = config.projectName;
  if (config.description) result.description = config.description;

  if (config.techStack) {
    const techStack: ConfigObject['techStack'] = {};
    if (config.techStack.languages?.length)
      techStack.languages = config.techStack.languages;
    if (config.techStack.frontend?.length)
      techStack.frontend = config.techStack.frontend;
    if (config.techStack.backend?.length)
      techStack.backend = config.techStack.backend;
    if (config.techStack.database?.length)
      techStack.database = config.techStack.database;
    if (config.techStack.infrastructure?.length)
      techStack.infrastructure = config.techStack.infrastructure;
    if (config.techStack.tools?.length)
      techStack.tools = config.techStack.tools;
    if (hasProperties(techStack)) result.techStack = techStack;
  }

  if (config.architecture) {
    const arch: ConfigObject['architecture'] = {};
    if (config.architecture.pattern) arch.pattern = config.architecture.pattern;
    if (config.architecture.componentStyle)
      arch.componentStyle = config.architecture.componentStyle;
    if (config.architecture.structure?.length)
      arch.structure = config.architecture.structure;
    if (hasProperties(arch)) result.architecture = arch;
  }

  if (config.conventions) {
    const conv: ConfigObject['conventions'] = {};
    if (config.conventions.naming && hasProperties(config.conventions.naming)) {
      conv.naming = {};
      if (config.conventions.naming.files)
        conv.naming.files = config.conventions.naming.files;
      if (config.conventions.naming.components)
        conv.naming.components = config.conventions.naming.components;
      if (config.conventions.naming.functions)
        conv.naming.functions = config.conventions.naming.functions;
      if (config.conventions.naming.variables)
        conv.naming.variables = config.conventions.naming.variables;
    }
    if (config.conventions.quotes) conv.quotes = config.conventions.quotes;
    if (config.conventions.semicolons !== undefined)
      conv.semicolons = config.conventions.semicolons;
    if (hasProperties(conv)) result.conventions = conv;
  }

  if (config.testStrategy) {
    const test: ConfigObject['testStrategy'] = {};
    if (config.testStrategy.approach)
      test.approach = config.testStrategy.approach;
    if (config.testStrategy.coverage !== undefined)
      test.coverage = config.testStrategy.coverage;
    if (config.testStrategy.mockingStrategy)
      test.mockingStrategy = config.testStrategy.mockingStrategy;
    if (config.testStrategy.frameworks?.length)
      test.frameworks = config.testStrategy.frameworks;
    if (hasProperties(test)) result.testStrategy = test;
  }

  if (config.ai) {
    const ai: ConfigObject['ai'] = {};
    if (config.ai.defaultModel) ai.defaultModel = config.ai.defaultModel;
    if (config.ai.primaryAgent) ai.primaryAgent = config.ai.primaryAgent;
    if (hasProperties(ai)) result.ai = ai;
  }

  return result;
}

/**
 * Check if object has non-empty arrays
 */
function hasNonEmptyArrays(obj: Record<string, unknown>): boolean {
  return Object.values(obj).some(v => Array.isArray(v) && v.length > 0);
}

/**
 * Check if object has any defined properties
 */
function hasProperties(obj: Record<string, unknown>): boolean {
  return Object.values(obj).some(v => v !== undefined && v !== null);
}

/**
 * Render tech stack section
 */
function renderTechStack(
  techStack: NonNullable<ConfigObject['techStack']>,
): string[] {
  const lines: string[] = [];

  if (techStack.languages?.length) {
    lines.push(`    languages: [${formatStringArray(techStack.languages)}],`);
  }
  if (techStack.frontend?.length) {
    lines.push(`    frontend: [${formatStringArray(techStack.frontend)}],`);
  }
  if (techStack.backend?.length) {
    lines.push(`    backend: [${formatStringArray(techStack.backend)}],`);
  }
  if (techStack.database?.length) {
    lines.push(`    database: [${formatStringArray(techStack.database)}],`);
  }
  if (techStack.infrastructure?.length) {
    lines.push(
      `    infrastructure: [${formatStringArray(techStack.infrastructure)}],`,
    );
  }
  if (techStack.tools?.length) {
    lines.push(`    tools: [${formatStringArray(techStack.tools)}],`);
  }

  return lines;
}

/**
 * Render architecture section
 */
function renderArchitecture(
  arch: NonNullable<ConfigObject['architecture']>,
): string[] {
  const lines: string[] = [];

  if (arch.pattern) {
    lines.push(`    pattern: '${escapeJsString(arch.pattern)}',`);
  }
  if (arch.componentStyle) {
    lines.push(`    componentStyle: '${escapeJsString(arch.componentStyle)}',`);
  }
  if (arch.structure?.length) {
    lines.push(`    structure: [${formatStringArray(arch.structure)}],`);
  }

  return lines;
}

/**
 * Render conventions section
 */
function renderConventions(
  conv: NonNullable<ConfigObject['conventions']>,
): string[] {
  const lines: string[] = [];

  if (conv.naming && hasProperties(conv.naming)) {
    lines.push('    naming: {');
    if (conv.naming.files) {
      lines.push(`      files: '${escapeJsString(conv.naming.files)}',`);
    }
    if (conv.naming.components) {
      lines.push(
        `      components: '${escapeJsString(conv.naming.components)}',`,
      );
    }
    if (conv.naming.functions) {
      lines.push(
        `      functions: '${escapeJsString(conv.naming.functions)}',`,
      );
    }
    if (conv.naming.variables) {
      lines.push(
        `      variables: '${escapeJsString(conv.naming.variables)}',`,
      );
    }
    lines.push('    },');
  }

  if (conv.quotes) {
    lines.push(`    quotes: '${escapeJsString(conv.quotes)}',`);
  }
  if (conv.semicolons !== undefined) {
    lines.push(`    semicolons: ${conv.semicolons},`);
  }

  return lines;
}

/**
 * Render test strategy section
 */
function renderTestStrategy(
  test: NonNullable<ConfigObject['testStrategy']>,
): string[] {
  const lines: string[] = [];

  if (test.approach) {
    lines.push(`    approach: '${escapeJsString(test.approach)}',`);
  }
  if (test.coverage !== undefined) {
    lines.push(`    coverage: ${test.coverage},`);
  }
  if (test.mockingStrategy) {
    lines.push(
      `    mockingStrategy: '${escapeJsString(test.mockingStrategy)}',`,
    );
  }
  if (test.frameworks?.length) {
    lines.push(`    frameworks: [${formatStringArray(test.frameworks)}],`);
  }

  return lines;
}

/**
 * Escape special characters in a string for safe JavaScript string literal output
 *
 * Prevents code injection by escaping:
 * - Backslashes (\) - must be escaped first
 * - Single quotes (') - prevents quote breakout
 * - Newlines (\n) - prevents multi-line syntax issues
 * - Carriage returns (\r)
 * - Tabs (\t)
 * - Null bytes (\x00) - defense-in-depth against string handling issues
 * - U+2028 (Line Separator) - breaks JS string literals
 * - U+2029 (Paragraph Separator) - breaks JS string literals
 */
export function escapeJsString(str: string): string {
  return (
    str
      .replace(/\\/g, '\\\\') // Escape backslashes first
      .replace(/'/g, "\\'") // Escape single quotes
      .replace(/\n/g, '\\n') // Escape newlines
      .replace(/\r/g, '\\r') // Escape carriage returns
      .replace(/\t/g, '\\t') // Escape tabs
      // eslint-disable-next-line no-control-regex
      .replace(/\x00/g, '\\x00') // Escape null bytes
      .replace(/\u2028/g, '\\u2028') // Escape Line Separator
      .replace(/\u2029/g, '\\u2029')
  ); // Escape Paragraph Separator
}

/**
 * Format string array for JS output
 */
function formatStringArray(arr: string[]): string {
  return arr.map(s => `'${escapeJsString(s)}'`).join(', ');
}
